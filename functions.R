### custom functions in simulation

## load packages
library(MASS)
library(geepack)

## generate a set of sequences of longitudinal data (Y0, A1, Y1, A2, Y2, Y3) from a joint distribution

generateData.joint <- function(N = 1000, # sample size 
                               alpha1 = 1, alpha2 = 1.5, alpha3 = 2, beta2 = 1, beta3 = 1.5, gamma2 = 1, gamma3 = 1.5, # coefficients of treatment effect
                               sigma.v = 2, sigma.e = 2, lambda1 = 0, lambda2 = 0, lambda3 = 0){ # parameters of correlation matrix
  Y0 <- rnorm(N, 0, 1)
  A1 <- 2*rbinom(N, 1, 0.5) - 1
  A2 <- 2*rbinom(N, 1, 0.5) - 1
  mu <- cbind(alpha1*Y0*A1, 
              alpha2*Y0*A1 + beta2*Y0*A2 + gamma2*A1*A2, 
              alpha3*Y0*A1 + beta3*Y0*A2 + gamma3*A1*A2)
  Sigma <- matrix(c(lambda1^2*sigma.v^2+sigma.e^2, lambda1*lambda2*sigma.v^2, lambda1*lambda3*sigma.v^2,
                    lambda1*lambda2*sigma.v^2, lambda2^2*sigma.v^2+sigma.e^2, lambda2*lambda3*sigma.v^2, 
                    lambda1*lambda3*sigma.v^2, lambda2*lambda3*sigma.v^2, lambda3^2*sigma.v^2+sigma.e^2), nrow = 3, ncol = 3)
  Y <- t(apply(mu, 1, function(x) mvrnorm(n = 1, mu = x, Sigma = Sigma))) # need MASS package
  dat <- cbind.data.frame("ID" = 1:N, "Y0" = Y0, "A1" = A1, "Y1" = Y[, 1],
                          "A2" = A2, "Y2" = Y[, 2], "Y3" = Y[, 3])
  return(dat)
}

## Q-learning algorithm without GEE, this algorithm analyzes a data set generated by "generateData.joint()"

Q <- function(dat, method = "SQ"){ # method can have value "SQ" or "MQ"
  ## stage 2
  dat.s2 <- cbind.data.frame(dat[ , c("ID", "Y0", "A1", "Y1", "A2", "Y2", "Y3")], 
                             "Q2" = dat$Y2 + dat$Y3) # collapse repeated measures at the end of stage 2
  mod.s2 <- glm(Q2 ~ Y0 + A1 + Y1 + A2 + A2 * (Y0 + A1 + Y1), data = dat.s2) # time is not a covariate in collapsed outcome model
  dat.s2.opt <- dat.s2 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 2
  # if A2 = -1
  dat.s2a <- dat.s2
  dat.s2a$A2 <- -1
  dat.s2a$Q2 <- predict(mod.s2, newdata = dat.s2a)
  # if A2 = 1
  dat.s2b <- dat.s2
  dat.s2b$A2 <- 1
  dat.s2b$Q2 <- predict(mod.s2, newdata = dat.s2b)
  # identify stage 2 optimal rule
  Q2a <- dat.s2a$Q2
  Q2b <- dat.s2b$Q2
  dat.s2.opt$A2 <- ifelse(Q2a > Q2b, -1, 1)
  # estimate the counterfactual outcomes using standard or modified Q-learning
  if (method == "SQ"){
    # standard Q-learning uses predictions from stage 2 model
    dat.s2.opt$R2 <- predict(mod.s2, newdata = dat.s2.opt)
  }
  if (method == "MQ"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int2 <- as.matrix(cbind.data.frame(dat.s2$A2, dat.s2$A2*dat.s2$Y0, dat.s2$A2*dat.s2$A1, dat.s2$A2*dat.s2$Y1)) %*% coef(mod.s2)[c(5:8)]
    dat.s2.opt$R2 <- dat.s2$Q2 + 2 * ifelse(dat.s2.opt$A2 == dat.s2$A2, 0, 1) * abs(int2)
  }
  
  ## stage 1
  dat.s1 <- cbind.data.frame(dat[ , c("ID", "Y0", "A1", "Y1")],
                             "A2" = dat.s2.opt$A2, # A2opt
                             "Q1" = dat$Y1 + dat.s2.opt$R2)
  mod.s1 <- glm(Q1 ~ Y0 * A1, data = dat.s1)
  dat.s1.opt <- dat.s1 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 1
  # A2 = -1
  dat.s1a <- dat.s1
  dat.s1a$A1 <- -1
  dat.s1a$Q1 <- predict(mod.s1, newdata = dat.s1a)
  # A2 = 1
  dat.s1b <- dat.s1
  dat.s1b$A1 <- 1
  dat.s1b$Q1 <- predict(mod.s1, newdata = dat.s1b)
  # identify stage 1 optimal rule
  Q1a <- dat.s1a$Q1
  Q1b <- dat.s1b$Q1
  dat.s1.opt$A1 <- ifelse(Q1a > Q1b, -1, 1)
  if (method == "SQ"){
    # standard Q-learning uses predictions from stage 1 model
    dat.s1.opt$R1 <- predict(mod.s1, newdata = dat.s1.opt)
  }
  if (method == "MQ"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int1 <- as.matrix(cbind.data.frame(dat.s1$A1, dat.s1$A1*dat.s1$Y0)) %*% coef(mod.s1)[c(3:4)]
    dat.s1.opt$R1 <- dat.s1$Q1 + ifelse(dat.s1.opt$A1 == dat.s1$A1, 0, 1) * abs(int1)
  }
  # output a data frame which contains the estimated optimal rules and outcomes
  dat.opt <- cbind.data.frame(dat.s1.opt[ , c("ID", "Y0", "A1", "A2", "R1")])
  # output a list of model parameters, original data set, and estimated optimal counterfactuals
  return(list("mod.s1" = mod.s1, "mod.s2" = mod.s2, "dat" = dat, "dat.opt" = dat.opt))
}

## Q-learning methods with GEE, this algorithm analyzes a data set generated by "generateData.joint()"
# users can specify the working correlation that best fit their interest, but "unstructured" is recommended

QGEE <- function(dat, method = "SQGEE", corstr = c("unstructured", "exchangeable")){ # method can have value "SQGEE" or "MQGEE"
  n <- nrow(dat)
  
  ## stage 2
  # convert the format of the data set from wide to long
  dat.s2 <- cbind.data.frame(do.call(rbind, replicate(2, dat[ , c("ID", "Y0", "A1", "Y1", "A2", "Y2", "Y3")], simplify = FALSE)), 
                             "time" = rep(c(2, 3), each = n), "Q2" = c(dat$Y2, dat$Y3)) # treat repeated measures at the end of stage 2 as an outcome vector
  dat.s2 <- dat.s2[order(dat.s2$ID), ]
  mod.s2 <- geeglm(Q2 ~ factor(time) + Y0 + A1 + Y1 + factor(time) *(Y0 + A1 + Y1) + A2 + A2 * (factor(time) + Y0 + A1 + Y1 + factor(time) *(Y0 + A1 + Y1)),
                   data = dat.s2, id = ID, corstr = corstr[2]) # need geepack package
  # mod.s2 <- geeglm(Q2 ~ factor(time) * Y0 * A1 * Y1 * A2,
  #                  data = dat.s2, id = ID, corstr = corstr[2]) # stage 2 full/exhaustive model
  dat.s2.opt <- dat.s2 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 2
  # A2 = -1
  dat.s2a <- dat.s2
  dat.s2a$A2 <- -1
  dat.s2a$Q2 <- predict(mod.s2, newdata = dat.s2a)
  # A2 = 1
  dat.s2b <- dat.s2
  dat.s2b$A2 <- 1
  dat.s2b$Q2 <- predict(mod.s2, newdata = dat.s2b)
  Q2a <- colMeans(matrix(dat.s2a$Q2, 2))
  Q2b <- colMeans(matrix(dat.s2b$Q2, 2))
  dat.s2.opt$A2 <- rep(ifelse(Q2a > Q2b, -1, 1), each = 2)
  if (method == "SQGEE"){
    # standard Q-learning uses predictions from stage 2 model
    dat.s2.opt$R2 <- predict(mod.s2, newdata = dat.s2.opt)
  }
  if (method == "MQGEE"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int2 <- as.matrix(cbind.data.frame(dat.s2$A2, dat.s2$A2*ifelse(dat.s2$time==3, 1, 0), dat.s2$A2*dat.s2$Y0,
                                       dat.s2$A2*dat.s2$A1, dat.s2$A2*dat.s2$Y1, 
                                       dat.s2$A2*dat.s2$Y0*ifelse(dat.s2$time==3, 1, 0), dat.s2$A2*dat.s2$A1*ifelse(dat.s2$time==3, 1, 0), 
                                       dat.s2$A2*dat.s2$Y1*ifelse(dat.s2$time==3, 1, 0))) %*% coef(mod.s2)[c(6, 10:16)]
    # # for stage 2 exhaustive model, uncomment the following
    # int2 <- as.matrix(cbind.data.frame(dat.s2$A2, dat.s2$A2*ifelse(dat.s2$time==3, 1, 0), dat.s2$A2*dat.s2$Y0,
    #                                    dat.s2$A2*dat.s2$A1, dat.s2$A2*dat.s2$Y1,
    #                                    dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$Y0, dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$A1,
    #                                    dat.s2$A2*dat.s2$Y0*dat.s2$A1, dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$Y1,
    #                                    dat.s2$A2*dat.s2$Y0*dat.s2$Y1, dat.s2$A2*dat.s2$A1*dat.s2$Y1,
    #                                    dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$Y0*dat.s2$A1,
    #                                    dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$Y0*dat.s2$Y1,
    #                                    dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$A1*dat.s2$Y1,
    #                                    dat.s2$A2*dat.s2$Y0*dat.s2$A1*dat.s2$Y1,
    #                                    dat.s2$A2*ifelse(dat.s2$time==3, 1, 0)*dat.s2$Y0*dat.s2$A1*dat.s2$Y1)) %*% coef(mod.s2)[c(6, 13:16 ,21:26, 28:32)]
    dat.s2.opt$R2 <- dat.s2$Q2 + 2 * ifelse(dat.s2.opt$A2 == dat.s2$A2, 0, 1) * abs(int2)
  }
  dat.s2.opt <- dat.s2.opt[order(dat.s2.opt$time), ]
  
  ## stage 1
  dat.s1 <- cbind.data.frame(do.call(rbind, replicate(3, dat[ , c("ID", "Y0", "A1", "Y1")], simplify = FALSE)), 
                             "A2" = rep(dat.s2.opt$A2[1:n], 3), # A2opt
                             "time" = rep(c(1, 2, 3), each = n), 
                             "Q1" = c(dat$Y1, dat.s2.opt$R2))
  dat.s1 <- dat.s1[order(dat.s1$ID), ]
  mod.s1 <- geeglm(Q1 ~ factor(time) * Y0 * A1, 
                   data = dat.s1, id = ID, corstr = corstr[1]) # stage 1 full model
  dat.s1.opt <- dat.s1 # create a data set that performs optimal treatment and stores counterfactual outcomes at stage 1
  # A2 = -1
  dat.s1a <- dat.s1
  dat.s1a$A1 <- -1
  dat.s1a$Q1 <- predict(mod.s1, newdata = dat.s1a)
  # A2 = 1
  dat.s1b <- dat.s1
  dat.s1b$A1 <- 1
  dat.s1b$Q1 <- predict(mod.s1, newdata = dat.s1b)
  Q1a <- colMeans(matrix(dat.s1a$Q1, 3))
  Q1b <- colMeans(matrix(dat.s1b$Q1, 3))
  dat.s1.opt$A1 <- rep(ifelse(Q1a > Q1b, -1, 1), each = 3)
  if (method == "SQGEE"){
    # standard Q-learning uses predictions from stage 1 model
    dat.s1.opt$R1 <- predict(mod.s1, newdata = dat.s1.opt)
  }
  if (method == "MQGEE"){
    # modified Q-learning uses the observed values and adds back the regret function if the observed treatment is suboptimal
    int1 <- as.matrix(cbind.data.frame(dat.s1$A1, dat.s1$A1*ifelse(dat.s1$time==2, 1, 0), dat.s1$A1*ifelse(dat.s1$time==3, 1, 0), dat.s1$A1*dat.s1$Y0, 
                                       dat.s1$A1*ifelse(dat.s1$time==2, 1, 0)*dat.s1$Y0, dat.s1$A1*ifelse(dat.s1$time==3, 1, 0)*dat.s1$Y0)) %*% coef(mod.s1)[c(5, 8:12)]
    dat.s1.opt$R1 <- dat.s1$Q1 + 2 * ifelse(dat.s1.opt$A1 == dat.s1$A1, 0, 1) * abs(int1)
  }
  # output a data frame which contains the estimated optimal rules and outcomes
  dat.opt <- cbind.data.frame(dat.s1.opt[ , c("ID", "Y0", "A1", "A2", "time", "R1")])
  # convert the format of dat.opt from long to wide
  dat.opt <- reshape(dat.opt, v.names = "R1",idvar = "ID", timevar = "time", direction = "wide", sep = "")
  # output a list of model parameters, original data set, and estimated optimal counterfactuals
  return(list("mod.s1" = mod.s1, "mod.s2" = mod.s2, "dat" = dat, "dat.opt" = dat.opt))
}
